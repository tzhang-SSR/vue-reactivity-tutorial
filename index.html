<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>手写Vue响应式-二魔</title>
</head>

<body>
    <h1>手写Vue响应式-二魔</h1>
</body>
<script>
    let activeEffect // 当前正在执行的副作用函数
    const effectStack = [] // 副作用函数栈
    const data = { foo: true, bar: true };
    const bucket = new WeakMap()

    function track(target, key) {
        // 没有 activeEffect，直接 return
        if (!activeEffect) return
        let depsMap = bucket.get(target)
        // 如果不存在，那么就新建一个与 target 关联的depsMap
        if (!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }

        // 如果不存在，同样新建一个与 key 关联的deps
        let deps = depsMap.get(key)
        if (!deps) {
            depsMap.set(key, (deps = new Set()))
        }
        // 最后将当前激活的副作用函数添加到deps中
        deps.add(activeEffect)
        // 副作用函数的依赖集合deps也反过来存储响应式变量的依赖集合deps
        activeEffect.deps.push(deps)
    }

    function trigger(target, key) {
        // 根据target从桶中取得 depsMap，再根据key取得所有副作用函数 effects，然后依次执行
        const depsMap = bucket.get(target)
        if (!depsMap) return
        const effects = depsMap.get(key)

        // 创建一个新的 Set 集合，用于存储需要执行的副作用函数
        const effectsToRun = new Set(effects)
        effectsToRun.forEach(fn => fn())
    }

    // 通过Proxy代理对数据的读取操作进行拦截
    const obj = new Proxy(data, {
        get(target, key) {
            track(target, key)
            return target[key]
        },
        set(target, key, newVal) {
            target[key] = newVal
            trigger(target, key)
        }
    })

    function cleanup(effectFn) {
        // 遍历 effectFn.deps 数组
        for (const dep of effectFn.deps) {
            // 将 effectFn 从依赖集合中移除
            dep.delete(effectFn)
        }
        // 最后将 effectFn.deps 数组清空, 防止内存泄漏
        effectFn.deps.length = 0
    }

    // 修改effect函数的功能，使其能够接收一个函数作为参数，并将该函数作为副作用函数执行
    function effect(fn) {
        const effectFn = () => {
            cleanup(effectFn)
            activeEffect = effectFn
            // 在调用副作用函数之前将当前副作用函数压入栈中
            effectStack.push(effectFn)
            fn()
            // 当前副作用函数执行完毕后，将activeEffect还原为之前的值
            effectStack.pop()
            activeEffect = effectStack[effectStack.length - 1]
        }
        // effectFn.deps 用来存储所有与该副作用函数相关联的依赖集合
        effectFn.deps = []
        // 执行副作用函数
        effectFn()
    }

    let tmp1, tmp2
    effect(function effectFn1() {
        console.log('执行effectFn1')

        effect(function effectFn2() {
            console.log('执行effectFn2')
            // 在 effectFn2 中读取obj.bar
            temp2 = obj.bar
        })
        // 在 effectFn1 中读取obj.foo
        temp1 = obj.foo
    })
    obj.foo = false

</script>

</html>